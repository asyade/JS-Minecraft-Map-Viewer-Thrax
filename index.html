<!DOCTYPE html>


<html lang="en">
	<head>
		<title>
			derp
		</title>
		<link rel="stylesheet" href="reset.css" />
<style type="text/css">
#fileContainer {
 min-height: 100px;
  width: 200px;
  border: 3px dashed #ccc;
  margin: 10px;
  padding: 10px;
}
</style>
		<script type="text/javascript" src="jquery-1.6.1.js"></script>
		<script type="text/javascript" src="Detector.js"></script>
		<script type="text/javascript" src="Three.js"></script>
		<script type="text/javascript" src="RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="BlockType.js"></script>
		<script type="text/javascript" src="BlockHandler.js"></script>
		<script type="text/javascript" src="DataReader.js"></script>
		<script type="text/javascript" src="util.js"></script>
		<script type="text/javascript" src="deflate.js"></script>
		<script type="text/javascript" src="inflate.js"></script>
		<script type="text/javascript" src="RegionFile.js"></script>
		<script type="text/javascript" src="nbt.js"></script>
		<script type="text/javascript">
			var CHUNK_SIZE_X = 16;
			var CHUNK_SIZE_Y = 128;
			var CHUNK_SIZE_Z = 16;
			var BLOCK_SIZE = 64;
			var SIZE_Y = 640;
			var SIZE_X = 800;
			var camera, scene, renderer;
			var ready;
			var blockData;
			var regions = new Array();
			var renderedChunks = new Array();
			
			var chunkBuffer = new Array();
			var playerChunks = new Array();

			var oldCoords = [null,null];
			scene = new THREE.Scene();

				
			$(function() {
				if ( ! Detector.webgl ) {
					Detector.addGetWebGLMessage();
				}
				init();
				animate();
				
				function init() {
					container = $("#container");
					materials = []
					
					var grass_dirt = loadTexture( 'textures/minecraft/grass_dirt.png' ),
					grass = loadTexture( 'textures/minecraft/grass.png' ),
					dirt = loadTexture( 'textures/minecraft/dirt.png' ),
					smoothstone = loadTexture( 'textures/minecraft/smoothstone.png' );
					sand = loadTexture( 'textures/minecraft/sand.png' );
					woodside = loadTexture( 'textures/minecraft/woodside.png' );
					woodtopbottom = loadTexture( 'textures/minecraft/woodtopbottom.png' );
					coal = loadTexture( 'textures/minecraft/coal.png' );
					leaves = loadTexture( 'textures/minecraft/leaves.png' );
					cactusSide = loadTexture( 'textures/minecraft/cactusside.png' );
					cactusTop = loadTexture( 'textures/minecraft/cactustop.png' );
					gravel = loadTexture( 'textures/minecraft/gravel.png' );
					sandstoneTop = loadTexture( 'textures/minecraft/sandStoneTop.png' );
					sandstoneSide = loadTexture( 'textures/minecraft/sandstoneSide.png' );
					sandstoneBottom = loadTexture( 'textures/minecraft/sandstoneBottom.png' );
					water = loadTexture( 'textures/minecraft/water.png' );
					lava = loadTexture( 'textures/minecraft/lava.png' );
					
					
	 
	 
					var textures = loadTexture('textures/minecraft/textures.png');
					
					grassMaterial = [
						grass_dirt, // right
						grass_dirt, // left
						grass, // top
						dirt, // bottom
						grass_dirt, // back
						grass_dirt  // front
					];
					lavaMaterial = [
						lava, // right
						lava, // left
						lava, // top
						lava, // bottom
						lava, // back
						lava  // front
					];
					waterMaterial = [
						water, // right
						water, // left
						water, // top
						water, // bottom
						water, // back
						water  // front
					];
					
					sandstoneMaterial = [
						sandstoneSide, // right
						sandstoneSide, // left
						sandstoneTop, // top
						sandstoneBottom, // bottom
						sandstoneSide, // back
						sandstoneSide  // front
					];
					
					cactusMaterial = [
						cactusSide, // right
						cactusSide, // left
						cactusTop, // top
						cactusTop, // bottom
						cactusSide, // back
						cactusSide  // front
					];
					
					gravelMaterial = [
						gravel, // right
						gravel, // left
						gravel, // top
						gravel, // bottom
						gravel, // back
						gravel  // front
					];
					
					woodMaterial = [
						woodside, // right
						woodside, // left
						woodtopbottom, // top
						woodtopbottom, // bottom
						woodside, // back
						woodside  // front
					];
					coalMaterial = [
						coal, // right
						coal, // left
						coal, // top
						coal, // bottom
						coal, // back
						coal  // front
					];
					leafMaterial = [
						leaves, // right
						leaves, // left
						leaves, // top
						leaves, // bottom
						leaves, // back
						leaves  // front
					];
					
					dirtMaterial = [
						dirt, // right
						dirt, // left
						dirt, // top
						dirt, // bottom
						dirt, // back
						dirt  // front
					];
					
					smoothStoneMaterial = [
						smoothstone, // right
						smoothstone, // left
						smoothstone, // top
						smoothstone, // bottom
						smoothstone, // back
						smoothstone  // front
					];
					
					sandMaterial = [
						sand, // right
						sand, // left
						sand, // top
						sand, // bottom
						sand, // back
						sand  // front
					];
					
					
					blockHandler = new BlockHandler();
					smoothStoneBlockType = new BlockType(1, smoothStoneMaterial);
					blockHandler.addType(smoothStoneBlockType);
					dirtBlockType = new BlockType(3, dirtMaterial);
					blockHandler.addType(dirtBlockType);
					grassBlockType = new BlockType(2, grassMaterial);
					blockHandler.addType(grassBlockType);
					sandBlockType = new BlockType(12, sandMaterial);
					blockHandler.addType(sandBlockType);
					woodBlockType = new BlockType(17, woodMaterial);
					blockHandler.addType(woodBlockType);
					coalBlockType = new BlockType(16, coalMaterial);
					blockHandler.addType(coalBlockType);
					leafBlockType = new BlockType(18, leafMaterial);
					blockHandler.addType(leafBlockType);
					cactusBlockType = new BlockType(81, cactusMaterial);
					blockHandler.addType(cactusBlockType);
					gravelBlockType = new BlockType(13, gravelMaterial);
					blockHandler.addType(gravelBlockType);
					sandstoneBlockType = new BlockType(24, sandstoneMaterial);
					blockHandler.addType(sandstoneBlockType);
					waterBlockType = new BlockType(9, waterMaterial);
					blockHandler.addType(waterBlockType);
					lavaBlockType = new BlockType(11, lavaMaterial);
					blockHandler.addType(lavaBlockType);
					
					
					camera = new THREE.QuakeCamera( {
						fov: 60, aspect: SIZE_X / SIZE_Y, near: 1, far: 20000,
						movementSpeed: 500, lookSpeed: 0.075, noFly: false, lookVertical: true, autoForward: false
					} );
					
					camera.position.x = (0 * 16) * BLOCK_SIZE;
					camera.position.y = 64 * BLOCK_SIZE;
					camera.position.z = (0 * 16) * BLOCK_SIZE;
						
					console.log("setting up renderer");
					renderer = new THREE.WebGLRenderer();
					renderer.setSize( SIZE_X, SIZE_Y );
					$(renderer.domElement).css("border","1px solid red").appendTo(container);
					console.log("renderer setup!");
					
				}
				
				function parseChunk(chunkInfo) {
						//just extract one region
						var hThreshold = -1;
						var chunkData = chunkInfo["data"];
						var chunkOffset = chunkInfo["chunkLoc"];
						var geometry = new THREE.Geometry();
						
						//var geometry = false;
						//for each coordinate
						for (var x = 0; x < CHUNK_SIZE_X; x++) {
							for (var y = 0; y < CHUNK_SIZE_Y; y++) {
								for (var z = 0; z < CHUNK_SIZE_Z; z++) {
									if (y > hThreshold) {
										//get the index for the block using the special formula
										var index = y + ( z * CHUNK_SIZE_Y + ( x * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) );
										
										//the block ID for the block at (x,y,z)
										var blockID = chunkData[index];
										
										//not air
										var cube = undefined;
										if (blockID != 0) {
											//get the index for which the faces will be blank facing those adjecent to a block
											newIndex = getNewBlockIndex(chunkData, x,y,z);
											
											//get the GL cube
											cube = blockHandler.getCorrectGLCube(blockID, newIndex);
											
											
											//merge the cube to the geometry
											if (cube != undefined) {
												cube.position.y = y*BLOCK_SIZE;
												cube.position.x = (x + chunkOffset[0] * 16) * BLOCK_SIZE;
												cube.position.z = (z + chunkOffset[1] * 16) * BLOCK_SIZE;
												if (geometry == false) {
													geometry = cube;
												}
												else
												{
													GeometryUtils.merge( geometry, cube );
												}
											}
										}
									}
								}
							}
						}
						
						//return the geometry for this block
						return geometry;
				}
				
				function getNewBlockIndex(chunkData, x,y,z) {
					var px, nx, py, ny, pz, nz;
												
					//{n,p}{x,y,z} is 1 if there is a block adjecent to it.
					nz = (z > 0 && chunkData[y + ( (z - 1) * CHUNK_SIZE_Y + ( (x) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
					pz = (z < (CHUNK_SIZE_Z-1) && chunkData[y + ( (z + 1) * CHUNK_SIZE_Y + ( (x) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
												
					px = (x > 0 && chunkData[y + ( (z) * CHUNK_SIZE_Y + ( (x - 1) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
					nx = (x < (CHUNK_SIZE_X-1) && chunkData[y + ( (z) * CHUNK_SIZE_Y + ( (x + 1) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
												
					ny = (y > 0 && chunkData[(y - 1) + ( (z) * CHUNK_SIZE_Y + ( (x) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
					py = (y < (CHUNK_SIZE_Y-1) && chunkData[(y + 1) + ( (z) * CHUNK_SIZE_Y + ( (x) * CHUNK_SIZE_Y * CHUNK_SIZE_Z ) )]) ? 1 : 0;
												
					//sides = { px: true, nx: true, py: true, ny: true, pz: true, nz: true };
					var newIndex = nz + 2*pz + 2*2*ny + 2*2*2*py + 2*2*2*2*nx + 2*2*2*2*2*px;
												
					return newIndex;
				}
					
				function animate() {
					requestAnimationFrame( animate );
					render();
					var x, y, z, chunkX, chunkZ, regionX, regionZ;
					x = Math.floor(camera.position.x/BLOCK_SIZE);
					y = Math.floor(camera.position.y/BLOCK_SIZE);
					z = Math.floor(camera.position.z/BLOCK_SIZE);
					chunkX = Math.floor(x/16);
					chunkZ = Math.floor(z/16);
					regionX = Math.floor(chunkX/32);
					regionZ = Math.floor(chunkZ/32);
					var coords = "(" + x + ", " + y + ", " + z + ")";
					var chunkCoords = "(" + chunkX + ", " + chunkZ + ")";
					var regionCoords = "(" + regionX + ", " + regionZ + ")";
					
					
					if (oldCoords[0] == null || (oldCoords[0] != chunkX || oldCoords[1] != chunkZ))
					{
						ready = true;
					}
					
					if (ready == true) {
						ready = false;
						console.log("YEAH");
						
						//compute the chunks needed to be rendered
						playerChunks = new Array();
						var RADIUS = 3;
						
						//chunkX, chunkY
						for (var lcv = 0; lcv < RADIUS; lcv++) {
							for (var lcv1 = 0; lcv1 < RADIUS; lcv1++) {
								playerChunks.push({x: chunkX + (RADIUS-1)/2 - lcv, z:  chunkZ + (RADIUS-1)/2 - lcv1});
							}
						}
						console.log(playerChunks);
						
						newChunkBuffer = new Array();
						for (var lcv = 0; lcv < chunkBuffer.length; lcv++) {
							remove = true;
							for (var lcv1 = 0; lcv1 < playerChunks.length; lcv1++) {
								if (chunkBuffer[lcv].x == playerChunks[lcv1].x && chunkBuffer[lcv].z == playerChunks[lcv1].z) {
									newChunkBuffer.push(chunkBuffer[lcv]);
									remove = false;
								}
								
							}
							
							if (remove) {
								console.log("removing mesh");
								scene.removeObject(chunkBuffer[lcv].mesh); //https://github.com/mrdoob/three.js/issues/116
							}
						}
						
						chunkBuffer = newChunkBuffer;
						//render new chunks
						$.each(playerChunks, function(index, item) {
							console.log("trying to render chunk at " + item.x + "," + item.z);
							if (!chunkRendered(item.x,item.z)) {
								if (regions.length != 0) {
									renderChunk(item.x,item.z,regions);
								}
							}
							else
							{
								console.log("rendered already");
							}
						});
						
					}
					
					
					oldCoords = [chunkX, chunkZ];
					printout("Player: " + coords + " Chunk: " + chunkCoords + " Region: " + regionCoords);
				}
				
				
				function chunkRendered(x,z) {
					for (var lcv = 0; lcv < chunkBuffer.length; lcv++) {
						if (chunkBuffer[lcv].x == x && chunkBuffer[lcv].z == z) {
							return true;
						}
					}
					
					return false;
				}
				
				function render() {
					renderer.render( scene, camera );
				}
				
				function loadTexture( path ) {
					var image = new Image();
					image.onload = function () { texture.needsUpdate = true; };
					image.src = path;
					var texture  = new THREE.Texture( image, new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.LinearMipMapLinearFilter );
					return new THREE.MeshLambertMaterial( { map: texture } );
				}
				
				function printout(s) {
					$("#progress").text(s);
				}
					fileContainer = $("#fileContainer");
					//this is fucking broken, if you remove this, don't expect drop to work
					fileContainer.bind('dragenter',function(event) {
						$(this).css("background","black");
					});
					
					//same here, don't remove this or don't expect drop to work
					fileContainer.bind('dragover',function(event) {
						event.stopPropagation();
						event.preventDefault();
					});
					
					
					fileContainer.bind('dragleave',function(event) {
						$(this).css("background","white");
					});
					
					fileContainer.bind('drop', function(event) {
						event.stopPropagation();
						event.preventDefault();
						var regionFiles = event.originalEvent.dataTransfer.files; 
						
						if (regionFiles.length == 0)
						{
							alert("error loading file");
							return;
						}
						
						var k = 0;
						$.each(regionFiles, function(index,region) {
							var re = new RegExp("\\br.(-{0,1}\\d+).(-{0,1}\\d+).mcr+\\b")
							var match = re.exec(region.fileName);
							var regionLoc = {x: parseInt(match[1]), z: parseInt(match[2])};
							var fr = new FileReader();
							
							fr.onerror = function(event) {
								console.log(event);
							}
							
						
							fr.onloadend= function(event) {
								var rLoc = regionLoc;
								console.log(rLoc);
								var data = event.target.result;
								var regionFile = new RegionFile(data, rLoc);
								regions.push(regionFile);
								k++;
								if (k == regionFiles.length) {
									ready = true;
								}
							};
							
							fr.readAsBinaryString(region);
							fr = null;
						});
					});
					
					
					function renderChunk(cx,cz, regions) {
						//renders this chunk at world location cx, cz
						//get the correct region for this chunk
						var regionX = Math.floor(cx/32);
						var regionZ = Math.floor(cz/32);
						var regionFile = null;
						
						$.each(regions, function(index, region) {
							if (region.regionLoc.x == regionX && region.regionLoc.z == regionZ) {
								console.log("DERP");
								regionFile = region;
							}
						});
						
						if (regionFile != null) {
							lcv = cx - 32*regionX;
							lcv1 = cz - 32*regionZ;
							rawChunk = regionFile.readNBTChunk(lcv,lcv1);
									
							if (rawChunk != null && rawChunk != false) {
								console.log("chunking");
								chunkNBT = new NBTReader(rawChunk);
										
								if (chunkNBT != null) {
									chunkData = chunkNBT.read(false);
									blocks = chunkData.root.Level.Blocks;
									regionOffsetX = regionFile.regionLoc.x * 32;
									regionOffsetZ = regionFile.regionLoc.z * 32;
									temp = {chunkLoc: [(lcv + regionOffsetX), (lcv1 + regionOffsetZ)], data: blocks};
									var g = parseChunk(temp);
									mesh = new THREE.Mesh( g, new THREE.MeshFaceMaterial() );
									scene.addObject( mesh );
									
									console.log("pushing " + cx + "," + cz);
									chunkBuffer.push({x: cx, z: cz, mesh: mesh});
								}
								else
								{
									console.log("error reading chunk NBT");
								}
							}
							else
							{
								console.log("no chunk here");
							}
						}
						else
						{
							console.log("no chunk exists");
						}
					}
		});
		</script>
	</head>
	<body>
		<div id="progress">progress</div>
		<div id="container"></div>
		<div id="fileContainer" >
			Drag a region file here
		</div>
		Example Map: Download <a href="map/region/r.0.0.mcr">this file</a> then drag it in the space above.
	</body>
</html>